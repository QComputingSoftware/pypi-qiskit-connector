# @Author: Dr. Jeffrey Chijioke-Uche, IBM Quantum Ambassador
# @last update: 2025-03-01

name: Qiskit Connector Code Coverage Analysis

on:
  push:
    branches: ["pypi"]
  workflow_dispatch:  
  schedule:
    - cron: '15 6 * * 1-5'  #  Mon-Fri at 06:15 UTC
    - cron: '39 11 * * 1-5' #  Mon-Fri at 11:39 UTC

permissions:
  contents: write
  id-token: write
  pull-requests: write
  actions: write
  deployments: write
  checks: write
  statuses: write
  issues: write
  discussions: write
  pages: write
  packages: write
  security-events: write
  repository-projects: write

env:
  FLEX_PLAN: ${{ secrets.FLEX_PLAN }}
  FLEX_PLAN_NAME: ${{ secrets.FLEX_PLAN_NAME }}
  FLEX_PLAN_CHANNEL: ${{ secrets.FLEX_PLAN_CHANNEL }}
  FLEX_PLAN_INSTANCE: ${{ secrets.FLEX_PLAN_INSTANCE }}

  OPEN_PLAN: ${{ secrets.OPEN_PLAN }}
  OPEN_PLAN_NAME: ${{ secrets.OPEN_PLAN_NAME }}
  OPEN_PLAN_CHANNEL: ${{ secrets.OPEN_PLAN_CHANNEL }}
  OPEN_PLAN_INSTANCE: ${{ secrets.OPEN_PLAN_INSTANCE }}

  PREMIUM_PLAN: ${{ secrets.PREMIUM_PLAN }}

  DEDICATED_PLAN: ${{ secrets.DEDICATED_PLAN }}
  DEDICATED_PLAN_NAME: ${{ secrets.DEDICATED_PLAN_NAME }}
  DEDICATED_PLAN_CHANNEL: ${{ secrets.DEDICATED_PLAN_CHANNEL }}
  DEDICATED_PLAN_INSTANCE: ${{ secrets.DEDICATED_PLAN_INSTANCE }}

  PAYGO_PLAN: ${{ secrets.PAYGO_PLAN }}
  PAYGO_PLAN_NAME: ${{ secrets.PAYGO_PLAN_NAME }}
  PAYGO_PLAN_CHANNEL: ${{ secrets.PAYGO_PLAN_CHANNEL }}
  PAYGO_PLAN_INSTANCE: ${{ secrets.PAYGO_PLAN_INSTANCE }}
  IQP_API_TOKEN: ${{ secrets.IQP_API_TOKEN }}

  GPG_NAME_REAL: ${{ secrets.GPG_NAME_REAL }}
  GPG_NAME_EMAIL: ${{ secrets.GPG_NAME_EMAIL }}
  GPG_NAME_COMMENT: ${{ secrets.GPG_NAME_COMMENT }}
  GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
  GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
  GPG_GITHUB_OPERATOR: ${{ secrets.GPG_GITHUB_OPERATOR }}
  EXPECTED_GPG_KEY_ID: ${{ secrets.EXPECTED_GPG_KEY_ID }}
  UNAME_CONTRIBUTOR_09: ${{ secrets.UNAME_CONTRIBUTOR_09 }}
  UNAME_CONTRIBUTOR_03: ${{ secrets.UNAME_CONTRIBUTOR_03 }}
  EMAIL_CONTRIBUTOR_09: ${{ secrets.EMAIL_CONTRIBUTOR_09 }}
  EMAIL_CONTRIBUTOR_03: ${{ secrets.EMAIL_CONTRIBUTOR_03 }}

jobs:
  coverage-badge:
    runs-on: ubuntu-latest

    steps:
      - name: ‚¨áÔ∏è Checkout main branch only
        uses: actions/checkout@v4
        with:
          ref: refs/heads/main   # üîí Avoid tag/branch ambiguity

      - name: Git Hard Reset Main
        run: |
          echo "Setting up Git user..."
          git config --global user.name "$GPG_NAME_REAL"
          git config --global user.email "$GPG_NAME_EMAIL"
          git reset --hard origin/main
          git pull origin main
      #_____________________________________________________________________________
      # This step is for setting up GPG keys for signing commits.
      #_____________________________________________________________________________
      - name: Install jq (JSON processor)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Fetch GitHub GPG Keys and Find Matching Key ID
        id: find_key
        run: |
          # EXPECTED_GPG_KEY_ID from secrets should be the 16-character GPG Key ID.
          echo "Searching for GPG key on GitHub with Key ID: $EXPECTED_GPG_KEY_ID"
          
          GPG_KEY_ID_MATCHED="" # Variable to store the matched API key_id
          key_found=false

          next_page_url="https://api.github.com/user/gpg_keys?per_page=100"

          while [[ -n "$next_page_url" ]]; do
              echo "Fetching GPG keys from: $next_page_url"
              header_file=$(mktemp)

              response_body=$(curl -s -L \
                                   -H "Authorization: token $GPG_GITHUB_OPERATOR" \
                                   -H "Accept: application/vnd.github+json" \
                                   -H "X-GitHub-Api-Version: 2022-11-28" \
                                   -D "$header_file" \
                                   "$next_page_url")
              curl_exit_status=$?

              if [ $curl_exit_status -ne 0 ]; then
                  echo "::error::Curl command failed with exit status $curl_exit_status for URL: $next_page_url"
                  rm -f "$header_file"
                  break
              fi

              if ! echo "$response_body" | jq -e '. | type == "array"' > /dev/null; then
                  echo "::warning::Response from $next_page_url was not a JSON array or was empty. Body: $response_body"
              fi

              # The API's 'key_id' field provides a 16-character ID.
              api_provided_key_ids=$(echo "$response_body" | jq -r '.[]? | .key_id // empty')

              if [[ -n "$api_provided_key_ids" ]]; then
                while IFS= read -r current_api_key_id; do # This is the 16-character ID from API
                    if [[ -z "$current_api_key_id" ]]; then
                        continue
                    fi
                    echo "Checking API provided key_id: $current_api_key_id"
                    
                    # Direct comparison: Does the API's 16-char key_id exactly match the 16-char EXPECTED_GPG_KEY_ID from secrets?
                    if [[ "$current_api_key_id" == "$EXPECTED_GPG_KEY_ID" ]]; then
                        echo "::notice::Match found! API Key ID '$current_api_key_id' matches Expected Key ID '$EXPECTED_GPG_KEY_ID'."
                        GPG_KEY_ID_MATCHED="$current_api_key_id"
                        key_found=true
                        break 2 # Exit both loops
                    fi
                done <<< "$api_provided_key_ids"
              fi

              link_header=$(grep -i '^Link:' "$header_file")
              if echo "$link_header" | grep -q 'rel="next"'; then
                  next_page_url=$(echo "$link_header" | sed -n 's/.*<\([^>]*\)>; rel="next".*/\1/p')
                  if [[ -z "$next_page_url" ]]; then
                      echo "::debug::'rel=\"next\"' found, but sed failed to extract URL. Link: $link_header"
                      next_page_url=""
                  fi
              else
                  next_page_url=""
              fi
              rm -f "$header_file"
          done

          if [[ "$key_found" == "true" ]]; then
            echo "Successfully matched API Key ID: $GPG_KEY_ID_MATCHED"
            echo "GPG_KEY_ID=$GPG_KEY_ID_MATCHED" >> $GITHUB_ENV
          else
            # This error message now clearly states what was being looked for.
            echo "::error::Expected GPG Key ID '$EXPECTED_GPG_KEY_ID' (from secrets) not found directly in any of the 'key_id' fields returned by the GitHub API after checking all pages."
            exit 1
          fi

      - name: Verify Found Key ID in Environment
        run: |
          if [[ -z "$GPG_KEY_ID" ]]; then
            echo "::error::GPG_KEY_ID environment variable was not set."
            exit 1
          else
            echo "Verified: GPG Key ID '$GPG_KEY_ID'."
            echo "GPG_KEY_ID is ready for use in subsequent GPG operations."
          fi

      - name: Import GPG Key, Configure Git, and Prepare for Signing
        id: gpg_id_01
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          echo "Setting GPG_TTY..."
          export GPG_TTY=$(tty)

          echo "Importing GPG key..."
          echo "${GPG_PASSPHRASE}" | gpg --batch --yes --pinentry-mode loopback --passphrase-fd 0 --import <(echo "${GPG_PRIVATE_KEY}")
          if [ $? -ne 0 ]; then
              echo "::error::GPG key import failed."
              exit 1
          fi
          echo "‚úÖ GPG key imported."

          echo "Testing GPG key with a simple sign operation using GPG_KEY_ID: ${GPG_KEY_ID}"
          echo "test data" | echo "${GPG_PASSPHRASE}" | gpg --batch --yes --pinentry-mode loopback --passphrase-fd 0 --clearsign --default-key "${GPG_KEY_ID}" > /dev/null
          if [ $? -ne 0 ]; then
              echo "::error::GPG sign test failed. Passphrase might not be available or key ID ('${GPG_KEY_ID}') is incorrect/ambiguous for GPG."
              exit 1
          fi
          echo "‚úÖ GPG key test successful."

          echo "Configuring git with GPG key details..."
          git config --global user.name "$GPG_NAME_REAL"
          git config --global user.email "$GPG_NAME_EMAIL"
          git config --global user.signingkey "$GPG_KEY_ID" 
          git config --global commit.gpgsign false # (default)

          test_gpg_key_id="0000000000000"
          echo "gpg_key_id=$GPG_KEY_ID" >> $GITHUB_ENV
          echo "gpg_key_id=$GPG_KEY_ID" >> $GITHUB_OUTPUT
          echo "test_gpg_key_id=$test_gpg_key_id" >> $GITHUB_OUTPUT
          echo "test_gpg_key_id=$test_gpg_key_id" >> $GITHUB_ENV
          echo "‚úÖ Git and GPG configured. Commits and tags will be signed using key."
      #_____________________________________________________________________________
      # End of GPG key setup
      #____________________________________________________________________________

      
      - name: üêç Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: üì¶ Install dependencies
        run: |
          pip install --upgrade pip setuptools wheel
          pip install pytest
          pip install coverage
          pip install pytest-cov
          pip install pytest-html
          pip install requests 
          pip install beautifulsoup4
          pip install --upgrade qiskit-connector
          pip list | grep qiskit
          echo "‚úÖ Qiskit connector packages listed."


      - name: üß™ Run pkg tests with coverage
        env:
          GH_TOKEN: ${{ secrets.PAT_GITHUB }}
        run: |
          SOURCE_DIR="qiskit_connector" # URL argument accepted as well.
          coverage_run() {
            # Array of coverage run options
            COVERAGE_COMMANDS=(
              "coverage run --source=qiskit_connector -m pytest tests/test_connector.py"
              "coverage run --source=qiskit_connector -m pytest -s tests/test_connector.py"
              "coverage run --source=qiskit_connector -m pytest -v tests/test_connector.py"
              "coverage run --source=qiskit_connector -m pytest -vs tests/test_connector.py"
              "coverage run --source=qiskit_connector -m pytest --disable-warnings tests/test_connector.py"
              "coverage run --source=qiskit_connector -m pytest -x tests/test_connector.py"
              "coverage run --branch --source=qiskit_connector -m pytest tests/test_connector.py"
              "coverage run --data-file=.coverage.qiskit --source=qiskit_connector -m pytest tests/test_connector.py"
              "coverage run --source=qiskit_connector -m pytest "
            )

            # Loop through commands and run until one succeeds
            for cmd in "${COVERAGE_COMMANDS[@]}"; do
              echo "Now Trying: $cmd"
              eval $cmd
              if [ $? -eq 0 ]; then
                echo "‚úÖ Success with: $cmd"
                echo "Coverage report:"
                coverage report || true
                return 0
              else
                echo "‚ùå Failed: $cmd"
              fi
            done
            echo "All coverage commands failed to run successfully."
            return 1
          }
          # To run::::::
          # coverage_run
          # exit 0

          # Run the coverage command: BareLine Option
          #-------------------------------------------
          coverage run -m pytest tests/test_qcon_func.py tests/test_qcon_os_compat.py tests/test_qcon_version.py tests/test_qcon_pkg.py tests/test_qcon_runtime.py tests/test_qcon_consumption.py tests/test_qcon_randomized.py tests/test_qcon_staggered.py tests/test_qcon_efficiency.py tests/test_qcon_resiliency.py
          REPORT_TABLE=$(coverage report || true)
          if [[ -z "$REPORT_TABLE" ]]; then
            echo "::warning::Coverage report is empty or not generated."
            exit 1
          else
            echo "‚úÖ All tests passed."
            echo "‚úÖ Coverage report generated successfully."
            BENCHMARK="36"
            echo "Benchmark for Qiskit-connector coverage: $BENCHMARK%"
            PASS_ID=1
            FAIL_ID=0
            coverage report || true
          fi
      
          STMTS=$(coverage report | grep "TOTAL" | awk '{print $2}')
          MISS=$(coverage report | grep "TOTAL" | awk '{print $3}')
          COVER=$(coverage report | grep "TOTAL" | awk '{print $4}')
          COVER_NUMERIC=$(echo "$COVER" | sed 's/%//')

          echo "Statements: $STMTS"
          echo "Missed: $MISS"
          echo "Coverage: $COVER"
          echo "Coverage Numeric: $COVER_NUMERIC"
          echo "PASS_ID: $PASS_ID"

          # Export for future steps
          echo "STMTS=$STMTS" >> $GITHUB_ENV
          echo "MISS=$MISS" >> $GITHUB_ENV
          echo "COVER=$COVER" >> $GITHUB_ENV
          echo "COVER_NUMERIC=$COVER_NUMERIC" >> $GITHUB_ENV
          echo "PASS_ID=$PASS_ID" >> $GITHUB_ENV
          echo "BENCHMARK=$BENCHMARK" >> $GITHUB_ENV
          echo "‚úÖ Coverage data exported to environment variables."

          # Check if any of the key coverage variables are empty or contain only spaces
          if [[ -z "${STMTS// }" || -z "${COVER// }" || -z "${MISS// }" || -z "${PASS_ID// }" ]]; then
            echo "‚ö†Ô∏è The following variables are empty:"
            [[ -z "${STMTS// }" ]] && echo "STMTS is empty."
            [[ -z "${COVER// }" ]] && echo "COVER is empty."
            [[ -z "${MISS// }" ]] && echo "MISS is empty."
            [[ -z "${PASS_ID// }" ]] && echo "PASS_ID is empty."
            echo "::warning::Coverage report is empty, not generated, or key metrics (Stmts, Cover, Miss) are missing."
            echo "::warning::Analysis incomplete & report may not be available. Exiting now."
            echo "‚ö†Ô∏è::warning::STOP ID: 00786"
            echo "::warning::Coverage report is empty, not generated, or key metrics (Stmts, Cover, Miss) are missing."
            echo "::warning::Analysis incomplete & report may not be available. Exiting now."
            exit 1
          else
              # This block executes if STMTS, COVER, AND MISS all have non-whitespace content
              echo "‚úÖ Coverage is within the acceptable threshold of $BENCHMARK benchmark. Current coverage is $COVER."
              echo "‚úÖ Analysis complete. Report available."
              echo "‚úÖ Coverage report is available."
          fi
          ### END OF COVERAGE TESTING ######################################################


      - name: üìä Analyze and compute qiskit-connector code coverage report
        id: coverage_id_02
        env:
          PASS_ID: ${{ env.PASS_ID }}
          FAIL_ID: ${{ env.FAIL_ID }}
          PASSRATE: ${{ env.PASSRATE }}
          STMTS: ${{ env.STMTS }}
          MISS: ${{ env.MISS }}
          COVER: ${{ env.COVER }}
          COVER_NUMERIC: ${{ env.COVER_NUMERIC }}
          BENCHMARK: ${{ env.BENCHMARK }}
        run: |
          coverage report || true

          if [[ "$PASS_ID" -eq 1 ]]; then
              echo "‚úÖ Tests reported successfully."
              SEGMENTED="$MISS"
              EFFICIENCY_POINTER=100

              QUOTIENT=$(echo "$STMTS - $SEGMENTED" | bc)
              PASSING=$(echo "$QUOTIENT * $COVER_NUMERIC / 100" | bc -l)
              COVERAGE=$(echo "$SEGMENTED + $PASSING" | bc -l | xargs printf "%.2f")
              ME=$(echo "$EFFICIENCY_POINTER - $COVERAGE" | bc -l)
              MARGINAL_ERROR=$(echo "$ME / 100" | bc -l)

              # Format outputs to two decimal places where appropriate
              printf "Total Executable Code: %s\n" "$STMTS"
              printf "Code Area Outside Qiskit Connector: %s\n" "$SEGMENTED"
              printf "Qiskit Connector Code Area: %s%%\n" "$COVER"
              printf "Qiskit Connector Numeric Coverage: %s\n" "$COVER_NUMERIC"
              printf "Passing Coverage (Computed): %.2f\n" "$PASSING"
              printf "Qiskit Connector Analyzed Coverage Status (Computed): %.2f\n" "$COVERAGE"
              printf "Marginal Error: %.4f\n" "$MARGINAL_ERROR"
          else
              echo "‚ö†Ô∏è::warning::STOP ID: 00998"
              echo "üîÑ::warning::Tests did not pass. Coverage report may be incomplete."
              echo "üîÑ::warning::This process will now terminate."
              echo "üîÑ::warning::This code analysis is incomplete - exiting now."
              exit 1
          fi

          # Set the coverage status as output for the next step
          #---------------------------------------------------
          echo "analyzed_status=$COVER" >> $GITHUB_OUTPUT
          COLOR_COVER="${COVER%\%}"
          echo "COLOR_COVER=$COLOR_COVER" >> $GITHUB_ENV

      #################################################################################
      # - name: üõ†Ô∏è Generate coverage badge                                           #
      #   uses: emibcn/badge-action@v2                                                #
      #   with:                                                                       #
      #     label: "Qiskit Connector Code Coverage Analysis"                          #
      #     label-color: "555"                                                        #
      #     status: "${{ steps.coverage.outputs.passrate }}%"                          #
      #     color: blue                                                               #
      #     style: classic                                                            #
      #     path: docs/badges/coverage.svg                                            #
      #################################################################################
     
      - name: Status Color Determination
        id: color_id_01
        env:
          COLOR_COVER: ${{ env.COLOR_COVER }}
        run: |
          if [[ "$COLOR_COVER" -lt 90 ]]; then
              STATUS_COLOR="yellow" # Orange/gold:#b7950b 
              echo "‚ö†Ô∏è Coverage is below 90%. Status color set to yellow."
              echo "üß™ Coverage: $COLOR_COVER% is below the threshold of 90%."
          else
              STATUS_COLOR="blue" # Blue
              echo "‚úÖ Coverage is above 90%. Status color set to blue."
              echo "üß™ Coverage: $COLOR_COVER% is above the threshold of 90%."
          fi
          echo "status_color=$STATUS_COLOR" >> $GITHUB_OUTPUT
          echo "STATUS_COLOR=$STATUS_COLOR" >> $GITHUB_ENV


      - name: üìÇ Ensure badge directory exists
        run: |
          mkdir -p docs/badges
          echo "‚úÖ Badge directory created or already exists."


      - name: üõ†Ô∏è Generate coverage badge
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          STATUS_COLOR: ${{ steps.color_id_01.outputs.status_color }}
        uses: emibcn/badge-action@v2
        with:
          label: "üõ°Ô∏èQiskit Connector Code Coverage Analysis"
          label-color: "555"
          status: "${{ steps.coverage_id_02.outputs.analyzed_status }}"
          color: "${{ steps.color_id_01.outputs.status_color }}"
          style: classic
          path: docs/badges/coverage.svg

################################################################################################################
#                                   GPG AUTO GENERATOR
################################################################################################################
      - name: GPG Auto Generator
        id: auto_gpg_id_01
        env:
          GPG_NAME_REAL: ${{ secrets.GPG_NAME_REAL }}
          GPG_NAME_EMAIL: ${{ secrets.GPG_NAME_EMAIL }}
          GPG_NAME_COMMENT: ${{ secrets.GPG_NAME_COMMENT }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          PAT_GITHUB: ${{ secrets.PAT_GITHUB }} # Needs read:gpg_key and write:gpg_key permissions
        shell: bash
        run: |
          set -e # Exit immediately if a command exits with a non-zero status.
          set -o pipefail # Causes a pipeline to return the exit status of the last command in the pipe that failed.

          # ANSI color codes
          RED='\033[0;31m'
          GREEN='\033[0;32m'
          YELLOW='\033[1;33m'
          BLUE='\033[0;34m'
          RESET='\033[0m'

          banner() {
            local color="$1"
            local msg="$2"
            echo -e "${color}==============================================================${RESET}"
            echo -e "${color}¬ª ${msg}${RESET}"
            echo -e "${color}==============================================================${RESET}"
          }

          GPGAUTO() {
            banner "${BLUE}" "üöÄ Starting Auto GPG Key Generation Process"

            if [[ -z "$GPG_NAME_REAL" || -z "$GPG_NAME_EMAIL" || -z "$GPG_PASSPHRASE" || -z "$PAT_GITHUB" ]]; then
              echo -e "${RED}‚õî ERROR: Required secrets (GPG_NAME_REAL, GPG_NAME_EMAIL, GPG_PASSPHRASE, PAT_GITHUB) are not all set.${RESET}"
              exit 1
            fi

            echo "üîß Ensuring GPG directory and permissions..."
            mkdir -p ~/.gnupg
            chmod 700 ~/.gnupg

            echo "üîß Configuring GPG and GPG Agent for non-interactive use..."
            grep -qxF "use-agent" ~/.gnupg/gpg.conf || echo "use-agent" >> ~/.gnupg/gpg.conf
            grep -qxF "pinentry-mode loopback" ~/.gnupg/gpg.conf || echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
            grep -qxF "allow-loopback-pinentry" ~/.gnupg/gpg-agent.conf || echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf
            
            echo "üîÑ Restarting GPG Agent to apply settings..."
            gpgconf --kill gpg-agent &>/dev/null || true
            gpg-agent --daemon --pinentry-program /usr/bin/pinentry-loopback --allow-loopback-pinentry

            echo "üîê Generating new GPG key with passphrase using batch configuration..."
            cat << EOF > gpg-batch.conf
            %echo Generating a GPG key
            Key-Type: RSA
            Key-Length: 4096
            Subkey-Type: RSA
            Subkey-Length: 4096
            Name-Real: ${GPG_NAME_REAL}
            Name-Email: ${GPG_NAME_EMAIL}
            Name-Comment: ${GPG_NAME_COMMENT:-Automatic Good Signing Key}
            Expire-Date: 0
            Passphrase: ${GPG_PASSPHRASE}
            %commit
            %echo Done
            EOF
            if ! gpg --batch --generate-key gpg-batch.conf; then
              echo -e "${RED}‚õî ERROR: GPG key generation failed.${RESET}"; exit 1
            fi
            echo "‚úÖ GPG key generated."

            echo "üîç Extracting GPG key identifiers for the new key..."
            GPG_FULL_FINGERPRINT=$(gpg --list-secret-keys --with-colons "$GPG_NAME_EMAIL" | awk -F: '/^sec:/ {key_id_line=NR+1} NR==key_id_line && /^fpr:/ {print $10}' | tail -n 1)
            if [[ -z "$GPG_FULL_FINGERPRINT" ]]; then
              echo -e "${RED}‚õî ERROR: Could not extract GPG key fingerprint.${RESET}"; exit 1
            fi
            GPG_KEY_ID_16CHAR="${GPG_FULL_FINGERPRINT: -16}" # Get last 16 chars for GitHub API comparison
            echo "üîë GPG Key Fingerprint (Full): $GPG_FULL_FINGERPRINT"
            echo "üîë GPG Key ID (16-char for GitHub): $GPG_KEY_ID_16CHAR"

            echo "üîé Checking if GPG key ($GPG_KEY_ID_16CHAR) already exists on GitHub..."
            existing_keys_response_code=$(curl -s -w "%{http_code}" -o existing_keys.json \
              -H "Authorization: token $PAT_GITHUB" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/user/gpg_keys")

            if [[ "$existing_keys_response_code" -ne 200 ]]; then
                echo -e "${RED}‚õî ERROR: Failed to fetch existing GPG keys from GitHub (HTTP $existing_keys_response_code).${RESET}"
                cat existing_keys.json # Print error response from GitHub
                exit 1
            fi

            # The GitHub API returns the 16-character key ID as the 'key_id' field for V4 keys
            key_already_exists=$(jq -r --arg keyid "$GPG_KEY_ID_16CHAR" '.[] | select(.key_id == $keyid) | .id' existing_keys.json)

            if [[ -n "$key_already_exists" ]]; then
              echo -e "${YELLOW}‚ö†Ô∏è GPG key with ID $GPG_KEY_ID_16CHAR (Fingerprint Suffix) already exists on GitHub (GitHub Key Database ID: $key_already_exists). Skipping upload.${RESET}"
            else
              echo "üì§ Exporting GPG public key for upload..."
              if ! gpg --armor --export "$GPG_FULL_FINGERPRINT" > publickey.asc; then
                echo -e "${RED}‚õî ERROR: GPG public key export failed.${RESET}"; exit 1
              fi
              if ! grep -q "BEGIN PGP PUBLIC KEY BLOCK" publickey.asc; then
                echo -e "${RED}‚õî ERROR: Exported public key file (publickey.asc) is invalid or empty.${RESET}"; exit 1
              fi
              echo "‚úÖ Public key exported to publickey.asc."

              echo "üåê Uploading GPG public key ($GPG_KEY_ID_16CHAR) to GitHub..."
              PUBKEY_FILE_CONTENT=$(cat publickey.asc) # Read entire file content
              JSON_PAYLOAD=$(jq -n \
                --arg name "GPG Auto-Generated Key $(date +%Y-%m-%d)" \
                --arg key "$PUBKEY_FILE_CONTENT" \
                '{name: $name, armored_public_key: $key}')

              upload_http_response_code=$(curl -s -w "%{http_code}" -o gh_upload_response.txt \
                -X POST https://api.github.com/user/gpg_keys \
                -H "Authorization: token $PAT_GITHUB" \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                -d "$JSON_PAYLOAD")

              echo "GitHub API Upload Response Body:"
              cat gh_upload_response.txt

              if [[ "$upload_http_response_code" -eq 201 ]]; then
                echo "‚úÖ Public key successfully uploaded to GitHub (HTTP $upload_http_response_code)."
              else
                echo -e "${RED}‚õî ERROR: Failed to upload public key to GitHub (HTTP $upload_http_response_code).${RESET}"
                # A 422 here might mean the key *content* is seen as a duplicate even if the ID check passed,
                # or the JSON payload was still somehow malformed.
                exit 1
              fi
            fi # End of if key_already_exists

            echo "‚öôÔ∏è Configuring Git to use this GPG key ($GPG_FULL_FINGERPRINT)..."
            git config --global user.name "$GPG_NAME_REAL"
            git config --global user.email "$GPG_NAME_EMAIL"
            git config --global user.signingkey "$GPG_FULL_FINGERPRINT"
            git config --global commit.gpgsign false
            git config --global gpg.program $(which gpg)
            echo "‚úÖ GPG key processing complete and Git configured!"

            echo "auto_generated_gpg_key_id=$GPG_KEY_ID_16CHAR" >> "$GITHUB_OUTPUT"
            echo "auto_generated_gpg_key_id=$GPG_KEY_ID_16CHAR" >> "$GITHUB_ENV"
            echo "auto_generated_gpg_fingerprint=$GPG_FULL_FINGERPRINT" >> "$GITHUB_OUTPUT"
            echo "auto_generated_gpg_fingerprint=$GPG_FULL_FINGERPRINT" >> "$GITHUB_ENV"

            echo "AUTO_GENERATED_GPG_KEY_ID=$GPG_KEY_ID_16CHAR" >> "$GITHUB_OUTPUT"
            echo "AUTO_GENERATED_GPG_KEY_ID=$GPG_KEY_ID_16CHAR" >> "$GITHUB_ENV"
            echo "AUTO_GENERATED_GPG_FINGERPRINT=$GPG_FULL_FINGERPRINT" >> "$GITHUB_OUTPUT"
            echo "AUTO_GENERATED_GPG_FINGERPRINT=$GPG_FULL_FINGERPRINT" >> "$GITHUB_ENV"

            # Clean up temporary files
            rm -f gpg-batch.conf publickey.asc gh_upload_response.txt existing_keys.json
          }

          # --- Main execution flow ---
          enable_status="on"
          if [ "$enable_status" == "on" ]; then
            echo "üöÄ Auto GPG key generation process is enabled by script."
            GPGAUTO
          else
            echo "üîí Auto GPG key generation is disabled by script."
          fi
######################################################################################################################
# End:: GPG AUTO GENERATOR.
######################################################################################################################

      - name: üöÄ Commit and Push Coverage Badge
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GPG_PRIVATE_KEY_FOR_REAL_ID: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE_FOR_REAL_ID: ${{ secrets.GPG_PASSPHRASE }}
          REAL_GPG_KEY_ID: ${{ steps.find_key.outputs.GPG_KEY_ID }}
          AUTO_GENERATED_GPG_KEY_ID: ${{ steps.auto_gpg_id_01.outputs.AUTO_GENERATED_GPG_KEY_ID }}
          COMMITTER_NAME: ${{ env.GPG_NAME_REAL }}
          COMMITTER_EMAIL: ${{ env.GPG_NAME_EMAIL }}
        run: |
          set -e # Exit immediately if a command exits with a non-zero status
          set -o pipefail # Ensure pipeline failures are caught

          echo "--- Step: Commit Badge to Repos ---"
          echo "Using REAL_GPG_KEY_ID: '${REAL_GPG_KEY_ID}'"
          echo "Using AUTO_GENERATED_GPG_KEY_ID: '${AUTO_GENERATED_GPG_KEY_ID}'"

          # 1. Configure Git User
          echo "Configuring Git user: '$COMMITTER_NAME <$COMMITTER_EMAIL>'..."
          git config --global user.name "$COMMITTER_NAME"
          git config --global user.email "$COMMITTER_EMAIL"
          # commit.gpgsign will be true, but we'll use explicit --gpg-sign=<keyid> for clarity

          # 2. Import Primary GPG Private Key (for REAL_GPG_KEY_ID)
          export GPG_TTY=$(tty)
          primary_key_usable=false
          if [[ -n "$GPG_PRIVATE_KEY_FOR_REAL_ID" && -n "$GPG_PASSPHRASE_FOR_REAL_ID" && -n "$REAL_GPG_KEY_ID" ]]; then
            echo "Importing GPG secret key for REAL_GPG_KEY_ID (${REAL_GPG_KEY_ID})..."
            echo "${GPG_PASSPHRASE_FOR_REAL_ID}" | gpg --batch --yes --pinentry-mode loopback --passphrase-fd 0 --import <(echo "${GPG_PRIVATE_KEY_FOR_REAL_ID}")
            if [ $? -eq 0 ]; then
              echo "‚úÖ GPG secret key for REAL_GPG_KEY_ID imported."
              echo "Verifying GPG key by signing test data with REAL_GPG_KEY_ID: ${REAL_GPG_KEY_ID}..."
              echo "test data" | echo "${GPG_PASSPHRASE_FOR_REAL_ID}" | gpg --batch --yes --pinentry-mode loopback --passphrase-fd 0 --clearsign --default-key "${REAL_GPG_KEY_ID}" > /dev/null
              if [ $? -eq 0 ]; then
                echo "‚úÖ GPG sign test successful for REAL_GPG_KEY_ID."
                primary_key_usable=true
              else
                echo "::warning::GPG sign test failed for REAL_GPG_KEY_ID. Primary signing will likely fail."
              fi
            else
              echo "::warning::GPG secret key import for REAL_GPG_KEY_ID failed. Primary signing will likely fail."
            fi
          else
            echo "::notice:: Secrets for REAL_GPG_KEY_ID not fully provided. Will rely on AUTO_GENERATED_GPG_KEY_ID if available."
          fi
          
          # 3. Add the badge and check for actual changes
          echo "Adding coverage badge: docs/badges/coverage.svg"
          git add docs/badges/coverage.svg

          if git diff --staged --quiet; then
            echo "‚úÖ No changes to 'docs/badges/coverage.svg' to commit. Workflow section for badge commit ends."
            exit 0 # Nothing to do, successful exit
          fi

          # 4. Attempt to commit, with GPG signing fallback logic
          commit_successful=false
          final_signing_key_id=""
          # Explicit and consistent commit message (without [skip ci])
          THE_COMMIT_MESSAGE="üõ°Ô∏è Qiskit Code Update - Qcon Intelligence Core"

          # Attempt 1: Use REAL_GPG_KEY_ID
          if [[ "$primary_key_usable" == "true" ]]; then
            echo "Attempting to commit and sign with REAL_GPG_KEY_ID: $REAL_GPG_KEY_ID"
            if git commit --gpg-sign="$REAL_GPG_KEY_ID" -m "$THE_COMMIT_MESSAGE"; then
              echo "‚úÖ Commit signed successfully with REAL_GPG_KEY_ID."
              commit_successful=true
              final_signing_key_id="$REAL_GPG_KEY_ID"
            else
              echo "::warning::Commit attempt with REAL_GPG_KEY_ID ($REAL_GPG_KEY_ID) failed. Exit code: $?. Will attempt fallback."
            fi
          else
            echo "::notice:: Primary key REAL_GPG_KEY_ID is not usable or not configured. Proceeding to fallback if available."
          fi

          # Attempt 2: Fallback to AUTO_GENERATED_GPG_KEY_ID
          if [[ "$commit_successful" == "false" ]]; then
            if [[ -n "$AUTO_GENERATED_GPG_KEY_ID" ]]; then
              echo "Attempting fallback: Commit and sign with AUTO_GENERATED_GPG_KEY_ID: $AUTO_GENERATED_GPG_KEY_ID"
              echo "This assumes its private key is available in the GPG agent."
              
              if git commit --gpg-sign="$AUTO_GENERATED_GPG_KEY_ID" -m "$THE_COMMIT_MESSAGE"; then
                echo "‚úÖ Commit signed successfully with AUTO_GENERATED_GPG_KEY_ID."
                commit_successful=true
                final_signing_key_id="$AUTO_GENERATED_GPG_KEY_ID"
              else
                commit_output_fallback=$(git commit --gpg-sign="$AUTO_GENERATED_GPG_KEY_ID" -m "$THE_COMMIT_MESSAGE" 2>&1 || true)
                echo "::error::Fallback GPG signing with AUTO_GENERATED_GPG_KEY_ID ($AUTO_GENERATED_GPG_KEY_ID) also failed."
                echo "Fallback commit output: $commit_output_fallback"
                exit 1
              fi
            else
              echo "::error::Commit signing failed with primary key, and no AUTO_GENERATED_GPG_KEY_ID available for fallback."
              exit 1
            fi
          fi

          # 5. Synchronize with remote AND Push the successfully committed changes
          if [[ "$commit_successful" == "true" ]]; then
            echo "Pushing commit (signed by $final_signing_key_id) to main..."
            
            echo "Fetching latest from origin 'main' before push..."
            git fetch origin main
            
            echo "Rebasing the new local commit(s) onto latest 'origin/main'..."
            if ! git rebase origin/main; then
                echo "::error::Rebase failed! This could be due to conflicts with recent changes on origin/main."
                echo "Attempting to abort rebase..."
                git rebase --abort || echo "::warning:: 'git rebase --abort' also failed or there was nothing to abort."
                echo "Manual intervention is likely required. The new badge commit was not pushed."
                exit 1
            fi
            echo "‚úÖ Rebase successful."

            git push origin main # Pushing current branch (main) to remote main
            if [ $? -ne 0 ]; then
              echo "::error::Final 'git push origin main' failed. Manual intervention may be needed."
              exit 1
            fi
            echo "‚úÖ Changes pushed successfully to main."
          else
            # This case implies no changes were staged initially, as commit failures otherwise exit.
            echo "‚úÖ No commit was made successfully (likely no changes were staged). Nothing to push."
          fi