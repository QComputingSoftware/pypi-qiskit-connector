# @Author: Dr. Jeffrey Chijioke-Uche, IBM Quantum Ambassador
# @last update: 2025-03-01

name: Qiskit Connector Code Coverage Analysis

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

  workflow_dispatch:  # Required for external workflows to trigger this via API

permissions:
  contents: write
  actions: write
  deployments: write
  pull-requests: write
  checks: write
  statuses: write
  issues: write
  discussions: write
  pages: write
  packages: write
  security-events: write
  repository-projects: write

env:
  GPG_NAME_REAL: ${{ secrets.GPG_NAME_REAL }}
  GPG_NAME_EMAIL: ${{ secrets.GPG_NAME_EMAIL }}
  GPG_NAME_COMMENT: ${{ secrets.GPG_NAME_COMMENT }}
  GPG_GITHUB_OPERATOR: ${{ secrets.GPG_GITHUB_OPERATOR }}
  EXPECTED_GPG_KEY_ID: ${{ secrets.EXPECTED_GPG_KEY_ID }}
  UNAME_CONTRIBUTOR_09: ${{ secrets.UNAME_CONTRIBUTOR_09 }}
  UNAME_CONTRIBUTOR_03: ${{ secrets.UNAME_CONTRIBUTOR_03 }}
  EMAIL_CONTRIBUTOR_09: ${{ secrets.EMAIL_CONTRIBUTOR_09 }}
  EMAIL_CONTRIBUTOR_03: ${{ secrets.EMAIL_CONTRIBUTOR_03 }}

jobs:
  coverage-badge:
    runs-on: ubuntu-latest

    steps:
      - name: ‚¨áÔ∏è Checkout main branch only
        uses: actions/checkout@v4
        with:
          ref: refs/heads/main   # üîí Avoid tag/branch ambiguity

      - name: Qiskit Connector Active State
        env:
          GH_TOKEN: ${{ secrets.PAT_GITHUB }}
        run: |
          python tests/pkg_active_check.py

      - name: üêç Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: üì¶ Install dependencies
        run: |
          pip install --upgrade pip setuptools wheel
          pip install pytest coverage pytest-cov
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          pip install qiskit-connector



      #_____________________________________________________________________________
      - name: Install jq (JSON processor)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Fetch GitHub GPG Keys and Find Matching Key ID
        id: find_key
        run: |
          # EXPECTED_GPG_KEY_ID from secrets should be the 16-character GPG Key ID.
          echo "Searching for GPG key on GitHub with Key ID: $EXPECTED_GPG_KEY_ID"
          
          GPG_KEY_ID_MATCHED="" # Variable to store the matched API key_id
          key_found=false

          next_page_url="https://api.github.com/user/gpg_keys?per_page=100"

          while [[ -n "$next_page_url" ]]; do
              echo "Fetching GPG keys from: $next_page_url"
              header_file=$(mktemp)

              response_body=$(curl -s -L \
                                   -H "Authorization: token $GPG_GITHUB_OPERATOR" \
                                   -H "Accept: application/vnd.github+json" \
                                   -H "X-GitHub-Api-Version: 2022-11-28" \
                                   -D "$header_file" \
                                   "$next_page_url")
              curl_exit_status=$?

              if [ $curl_exit_status -ne 0 ]; then
                  echo "::error::Curl command failed with exit status $curl_exit_status for URL: $next_page_url"
                  rm -f "$header_file"
                  break
              fi

              if ! echo "$response_body" | jq -e '. | type == "array"' > /dev/null; then
                  echo "::warning::Response from $next_page_url was not a JSON array or was empty. Body: $response_body"
              fi

              # The API's 'key_id' field provides a 16-character ID.
              api_provided_key_ids=$(echo "$response_body" | jq -r '.[]? | .key_id // empty')

              if [[ -n "$api_provided_key_ids" ]]; then
                while IFS= read -r current_api_key_id; do # This is the 16-character ID from API
                    if [[ -z "$current_api_key_id" ]]; then
                        continue
                    fi
                    echo "Checking API provided key_id: $current_api_key_id"
                    
                    # Direct comparison: Does the API's 16-char key_id exactly match the 16-char EXPECTED_GPG_KEY_ID from secrets?
                    if [[ "$current_api_key_id" == "$EXPECTED_GPG_KEY_ID" ]]; then
                        echo "::notice::Match found! API Key ID '$current_api_key_id' matches Expected Key ID '$EXPECTED_GPG_KEY_ID'."
                        GPG_KEY_ID_MATCHED="$current_api_key_id"
                        key_found=true
                        break 2 # Exit both loops
                    fi
                done <<< "$api_provided_key_ids"
              fi

              link_header=$(grep -i '^Link:' "$header_file")
              if echo "$link_header" | grep -q 'rel="next"'; then
                  next_page_url=$(echo "$link_header" | sed -n 's/.*<\([^>]*\)>; rel="next".*/\1/p')
                  if [[ -z "$next_page_url" ]]; then
                      echo "::debug::'rel=\"next\"' found, but sed failed to extract URL. Link: $link_header"
                      next_page_url=""
                  fi
              else
                  next_page_url=""
              fi
              rm -f "$header_file"
          done

          if [[ "$key_found" == "true" ]]; then
            echo "Successfully matched API Key ID: $GPG_KEY_ID_MATCHED"
            echo "GPG_KEY_ID=$GPG_KEY_ID_MATCHED" >> $GITHUB_ENV
          else
            # This error message now clearly states what was being looked for.
            echo "::error::Expected GPG Key ID '$EXPECTED_GPG_KEY_ID' (from secrets) not found directly in any of the 'key_id' fields returned by the GitHub API after checking all pages."
            exit 1
          fi

      - name: Verify Found Key ID in Environment
        run: |
          if [[ -z "$GPG_KEY_ID" ]]; then
            echo "::error::GPG_KEY_ID environment variable was not set."
            exit 1
          else
            echo "Verified: GPG Key ID '$GPG_KEY_ID'."
            echo "GPG_KEY_ID is ready for use in subsequent GPG operations."
          fi

      - name: Import GPG Key, Configure Git, and Prepare for Signing
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          echo "Setting GPG_TTY..."
          export GPG_TTY=$(tty)

          echo "Importing GPG key..."
          echo "${GPG_PASSPHRASE}" | gpg --batch --yes --pinentry-mode loopback --passphrase-fd 0 --import <(echo "${GPG_PRIVATE_KEY}")
          if [ $? -ne 0 ]; then
              echo "::error::GPG key import failed."
              exit 1
          fi
          echo "‚úÖ GPG key imported."

          echo "Testing GPG key with a simple sign operation using GPG_KEY_ID: ${GPG_KEY_ID}"
          echo "test data" | echo "${GPG_PASSPHRASE}" | gpg --batch --yes --pinentry-mode loopback --passphrase-fd 0 --clearsign --default-key "${GPG_KEY_ID}" > /dev/null
          if [ $? -ne 0 ]; then
              echo "::error::GPG sign test failed. Passphrase might not be available or key ID ('${GPG_KEY_ID}') is incorrect/ambiguous for GPG."
              exit 1
          fi
          echo "‚úÖ GPG key test successful."

          echo "Configuring git with GPG key details..."
          git config --global user.name "$GPG_NAME_REAL"
          git config --global user.email "$GPG_NAME_EMAIL"
          git config --global user.signingkey "$GPG_KEY_ID" 
          git config --global commit.gpgsign true

          echo "‚úÖ Git and GPG configured. Commits and tags will be signed using key."
      #_____________________________________________________________________________


     # ... (previous steps: checkout, setup python, install deps) ...

      - name: üß™ Run tests with coverage
        run: |
          coverage run --source=qiskit_connector -m pytest
          # Optional: Add error handling here if tests fail but you still want to report 0% coverage
          # e.g., coverage run ... || echo "Tests failed, coverage might be 0"

      - name: üìä Generate and Extract coverage percentage
        id: coverage
        run: |
          echo "--- Full coverage report output ---"
          coverage report
          echo "-----------------------------------"
          
          # Attempt to extract coverage. Default to 0 if not found or an error occurs.
          COVERAGE_VALUE=$(coverage report | grep "TOTAL" | awk '{print $NF}' | sed 's/%//' || echo "0")
          
          if [[ -z "$COVERAGE_VALUE" ]] || ! [[ "$COVERAGE_VALUE" =~ ^[0-9]+$ ]]; then
            echo "::warning::Could not parse coverage percentage, defaulting to 0."
            COVERAGE_VALUE="0"
          fi
          
          echo "Coverage Value: $COVERAGE_VALUE"
          echo "Coverage String for Badge: $COVERAGE_VALUE%"
          
          # This output will be used by the badge action
          echo "coverage_status_string=$COVERAGE_VALUE%" >> "$GITHUB_OUTPUT"
          # This output is just the number, in case needed elsewhere
          echo "coverage_numeric_value=$COVERAGE_VALUE" >> "$GITHUB_OUTPUT"

      - name: üìÇ Ensure badge directory exists
        run: |
          mkdir -p docs/badges
          # No need to rm here if the badge action overwrites or creates

      - name: üõ†Ô∏è Generate coverage badge
        uses: emibcn/badge-action@v2
        with:
          label: "Qiskit Connector Code Coverage" #
          label-color: "555"
          status: "${{ steps.coverage.outputs.coverage_status_string }}"
          color: ${{ steps.coverage.outputs.coverage_numeric_value > 90 && 'brightgreen' || (steps.coverage.outputs.coverage_numeric_value > 70 && 'green' || (steps.coverage.outputs.coverage_numeric_value > 50 && 'yellow' || 'red')) }}
          style: "flat" # 
          path: "docs/badges/coverage.svg"
    

      # ... (subsequent Git GPG, commit, and push steps) ...


      # Ensure the 'Commit coverage:
      - name: üåç Fetch origin and Prepare Branch for Badge Commit
        run: |
          git config --global user.name "${{ env.GPG_NAME_REAL }}"
          git config --global user.email "${{ env.GPG_NAME_EMAIL }}"
          echo "Synchronizing with remote main..."
          git fetch origin main
          git checkout -B main origin/main # Reset local main to remote main
          echo "‚úÖ Local main branch synchronized with origin/main."


      - name: üñäÔ∏è Commit coverage badge update
        run: |
          git add docs/badges/coverage.svg
          if git diff --cached --quiet; then
            echo "‚úÖ No changes to coverage badge to commit."
          else
            echo "üìù Committing updated coverage badge..."
            git commit -S"$GPG_KEY_ID" -m "üìä Qiskit Connector Coverage Report ${{ steps.coverage.outputs.coverage_status_string }} [skip ci]"
            echo "‚úÖ Coverage badge changes committed."
          fi

      - name: üöÄ Push badge changes
        run: |
          if ! git diff --quiet HEAD origin/main; then
            echo "‚¨ÜÔ∏è Pushing changes to main..."
            git push origin main
            if [ $? -ne 0 ]; then
                echo "::error::Git push failed. Trying rebase strategy..."
                git fetch origin main
                git rebase origin/main
                git push origin main
                if [ $? -ne 0 ]; then
                    echo "::error::Git push failed even after rebase. Manual intervention may be needed."
                    exit 1
                fi
            fi
            echo "‚úÖ Badge changes pushed."
          else
            echo "‚úÖ No new badge commit to push, or branch is not ahead."
          fi